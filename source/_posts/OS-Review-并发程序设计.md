---
title: OS-Review-并发程序设计
date: 2025-06-01 18:06:21
tags: [操作系统]
categories: "课程复习"
---
<!-- toc -->

# 六、并发程序设计

## 并发进程

### 概念

程序设计的一般习惯是顺序程序设计，**顺序程序设计**具有顺序性、封闭性、确定性、可再现性。

多道程序设计允许多个进程**并发执行**。OS 保证按照“顺序程序设计”方法编制的程序在并发执行时不受影响，如同独占计算机。这些按照顺序程序设计思想编制的进程在中并发执行属于**无关的并发进程**。

使一个程序分成若干个可同时执行的程序模块的方法称 **并发程序设计(concurrent programming)**

​	并发性、共享性、交往性

### 制约关系

**无关**的并发进程：一组并发进程分别在**不同的变量集合**上运行

> 并发进程的无关性是进程的执行与时间无关的一个充 分条件，又称为 **Bernstein 条件**
>
> <u>((R(p1)∩W(p2))∪(R(p2)∩W(p1))∪(W(p1)∩W(p2))= $\empty$</u> 则并发进程的执行与时间无关

**交往**的并发进程：一组并发进程**共享某些变量**， 一个进程的执行可能影响其他并发进程的结果

1. 时间相关的错误：结果错误、永远等待
2. **竞争：互斥**（死锁和饥饿）
3. **协作：同步**

## 临界区管理

**临界资源：互斥共享变量所代表的资源**

1. 关中断：最简单，直接在访问临界区时禁止中断
2. 测试并建立指令
3. 互换指令

## ⭐⭐**信号量与PV操作**

### 数据定义

设**s**为一个**记录型数据结构**,一个分量为整型量value,另一个为**信号量队列queue**, P和V操作原语定义：

- **P(s)**：将信号量**s减去1**，若结果**小于0**，则调用P(s)的进程被置成**等待**信号量s的状态
-  **V(s)**：将信号量**s加1**，若结果**不大于0**，则**释放(唤醒)**一个等待信号量s的进程，使其**转换为就绪态**

> 原语：CPU处于内核态，在<u>关中断</u>环境下执行的一段指令序列
>
> 原子性：不被中断，确保安全且完整执行这段指令序列

### 信号量与进程状态转换模型及其队列模型

​	<img src="操作系统知识点整理/QQ20250531-214655.png" style="zoom: 33%;" />

​	<img src="操作系统知识点整理/QQ20250531-214726.png" style="zoom: 33%;" />

> 推论
>
> - 信号量s为正值，表示还可进行的P操作次数，也代表剩余空闲资源数
>
> - 信号量s为负值，绝对值等于等待进程数
>
> P操作意味着**请求**一个资源，V操作意味着**释放**一个资源；P操作代表**阻塞进程操作**，而V操作代表**唤醒被阻塞进程**的操作

### **哲学家就餐问题**

有五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每 人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥 饿、然后吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子 。

```c
semaphore fork[5];
for (int i=0;i<5;i++)
 	fork[i]=1;
cobegin
process philosopher_i( ) {   //i= 0,1,2,3,4
while(true) {
 	think( );
	P(fork[i]);
	P(fork[(i+1)%5]);  // 两个P操作间可能产生死锁：所有人同时举起左手边的叉子
 	eat( );
 	V(fork[i]);
 	V(fork[(i+1)%5]);
 	}
}
coend
```

**解决方法**：

1. **(C. A. R. Hoare方案)**至多允许四个哲学家同时取叉子

   ```c
   room = 4；
   P(room) // 房间里最多四人
   	P(fork[i]);
   	P(fork[(i+1)%5]);
    	eat( );
    	V(fork[i]);
    	V(fork[(i+1)%5]);
   V(room)
   ```

2. 奇数号先取左手边的叉子，偶数号先取右手边的叉子

   ```c
   P(fork[i]); 
   P(fork[(i+1) % 5]);
   或
   P(fork[(i+1) % 5]); 
   P(fork[i]);	// 邻座二人必然对抗
   ```

   也可以简单一点，只让**其中一个哲学家先取右手**，这样也不会陷入死锁。

3. **(AND型信号量)**每个哲学家取到手边的两把叉子才吃，否则一把叉子也不取

### **生产者与消费者问题**

环形缓冲区，一个生产者放，一个消费者拿；消费者要在生产者放了的缓冲区拿，生产者要在空的缓冲区放。

1. **一个生产者 / 一个消费者 / 一个缓冲单元**

   ```c
   sput=1; // 表示初始允许放入一件产品
   sget=0; // 目前没有产品
   
   Process producer
    begin
    L1: 
   	produce a product; 
   	P(sput);  	// sput - 1,  表示申请一个空位，put之后空位消失；若无空位则阻塞
   	B=product; 
   	V(sget);	// sget + 1,  表示释放一个正在等待get的进程，也就是唤醒消费者
   	goto L1; 
   end; 
   
   Process consumer
    begin
    L2: 
   	P(sget); 	// sget - 1,  表示申请一个可get位，get后再次为空；若无法get则阻塞
   	product=B; 
   	V(sput); 	// sput + 1,  表示释放一个正在等待put的进程，即唤醒生产者
   	consume a product; 
   	goto L2; 
   end;
   ```

   > 最简单的生产者-消费者模型，是之后所有变体的基础

2. **一个生产者 / 一个消费者 / 多个缓冲单元**

   ```c
   sput = k // 允许放入k个
   sget = 0
   
   P(sput);  	
   B[putptr]=product;	
   putptr = (putptr+1)%k	
   V(sget);	
   
   P(sget);  	
   product=B[getptr];
   getptr = (getptr+1)%k
   V(sput);	
   ```

   > put和get各自维护一个指针，随着put或get的进行向前进

3. **多个生产者 / 多个消费者 / 多个缓冲单元**

   ```c
   s1 = 1; s2 = 1; // 多个进程共享putptr和getptr，所以需要互斥使用
   
   P(sput);  	
   	p(s1);	// 拒绝其他写进程使用putptr
   		B[putptr] = product;	
   		putptr = (putptr+1)%k	
   	V(s1);
   V(sget);	
   
   
   P(sget);  	
   	p(s2);	// 拒绝其他读进程使用getptr
   		product = B[getptr];
   		getptr = (getptr+1)%k
       V(s2);
   V(sput);
   ```

   > 如果只用一个互斥信号量s，在读的时候也拒绝了写的进程。

### **苹果橘子问题**

一个盘子，爸爸放苹果，妈妈放橘子；女儿取苹果，儿子取橘子。盘子里只能放一个水果。

```
sp = 1; // 初始盘子允许放一个水果
sg1 = 0; //  没有橘子
sg2 = 0; //  没有苹果

process father:
begin:
	L1 : 削苹果
		P(sp);	// 请求空盘子
		放苹果;
		V(sg2);  // 可以拿苹果了
    goto L1;
end;

process mother:
begin:
	L2 : 削橘子
		P(sp);	// 请求空盘子
		放橘子;
		V(sg1);  // 可以拿橘子了
    goto L2;
end;

process son:
begin:
	L3 : 
		P(sg1);	// 请求橘子
		拿橘子;
		V(sp);  // 盘子空了
    goto L3;
end;

process daughter:
begin:
	L4 : 
		P(sg2);	// 请求橘子
		拿苹果;
		V(sp);  // 盘子空了
    goto L4;
end;
```

> 同一个信号量的P操作和V操作可能分散，但一定是逻辑上闭环的。有P就有V。找到什么资源在被谁共享、会怎样变化就行。

### **读者写者问题**

读之间不互斥，读与写、写与写之间互斥

```c
rmutex=1; wmutex=1; S=1;
int readcount = 0 // 记录有几个进程正在读文件

process reader_i(  ) {
 	while (true)  {
    P(s);    					// 解决“读者优先”问题
 		P(rmutex);					// 维护readcount临界区
 			if (readcount==0) P(wmutex);	// 第一个读进程申请资源
			readcount++;			// 非第一个读进程直接进入
 		V(rmutex);
    V(s);    
        读文件；
		P(rmutex);
 			readcount--;
 			if(readcount==0)  V(wmutex);
 		V(rmutex);
 	}
 }
 
process writer_i(  ) {
 	while(true) {
    P(s);
 		P(wmutex);
			写文件；
		V(wmutex);
    V(s);
	}
}
```

> 一个混淆性极强的例子。可以这样想：
> **假设读读、读写、写写都互斥**，读和写应该都共用**一个**信号量**rw=1**，有：
>
> ```c
> Reading: P(rw); 读; V(rw);
> Writing: P(rw); 写; R(rw);
> ```
>
> 然而由题设，读和读是不互斥的。这里是怎么解决的呢？
>
> **但凡有一个进程在读时**，**其他的读进程都可以随便进来读**，只有写进程不能进来。那么就**只有第一个读进程需要申请信号量**，其他读进程跟着喝汤就行了。当**所有读进程都离开**，才轮到写进程进入。
>
> 于是，我们定义readcount=0，表示**目前在读的进程数**。
>
> 当readcount>0时，说明**至少有一个读进程正在读**，那再来几个读进程也无妨。当readcount==0时，说明**读进程已经全部退出了**，这时就可以释放rw，表示现在**允许写**了。
>
> ```c
> Reading:
> 	if(count==0) P(rw);  // 第一个读进程，要申请资源
> 	count++;			// 不是第一个，直接进入
> 	读;
> 	count--;			// 读完就退出
> 	if(count==0) V(rw);  // 没有读进程正在读了，释放资源，允许写
> 	
> Writing:
> 	P(rw);
> 	写;
> 	V(rw);
> ```
>
> 这个时候出现一个问题，count是一个多个读进程的**共享变量**，又是一个新的临界区，于是我们需要一个互斥信号量mutex=1来保护它。
>
> ```c
> Reading:
> 	P(mutex);
>         if(count==0) P(rw);  
>         count++;		
>     V(mutex);
>         读;
>     P(mutex);
>         count--;			
>         if(count==0) V(rw);  
>     V(mutex);
> ```
>
> 这就是混淆的地方，课件里给出的两个信号量是rmutex和wmutex，很容易让人以为一个处理读、一个处理写。事实上，最终决定读写资源分配的只有wmutex（也就是这里的rw），rmutex是用来保护count的！
>
> 最后还有一个问题，上面说的到count==0时释放资源，然后才轮到写进程。在count>0的大部分时间里，写进程的请求都被阻塞了。**只要读进程一直读，写进程就永远在等待**。
>
> 于是我们再定义信号量S=1；
>
> ```c
> Reading:
> 	P(S);
> 		P(mutex);
>        		...		
>     	V(mutex);
> 	V(S);
> 		读;
> 		P(mutex);
>        		...		
>     	V(mutex);
>     	
> Writing:
> 	P(S);
> 		P(rw);
> 		写;
> 		V(rw);
> 	V(S);
> ```
>
> 加上这一个S的效果是什么呢？就是**让所有读和写进程按申请顺序一起排队**，当一个写进程前面的读进程执行完了，就立马执行这个写进程。至于在该写进程之后申请的读进程呢，因为被P(S)拦截，不能再进入读的过程，只有当它前面的写进程结束了释放S的时候，才会轮到它再次去读。这样就保证了**公平性**。
>
> **最终代码如课件所示。**

### **睡眠的理发师问题**

理发店理有一位理发师、一把理发椅和n把供等候 理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉。一个顾客到来时，叫醒理发师。如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。

```c
int waiting=0;              //等候理发顾客坐的椅子数
int CHAIRS=N;               //为顾客准备的椅子数

 customers=0; barbers=0; mutex=1;
 
process barber( ) {
 while(true) {
 	P(customers);	 
		//有顾客吗?若无顾客,理发师睡眠
	P(mutex);           
			//若有顾客时，进入临界区
		waiting--;  //等候顾客数少一个
        V(barbers); //理发师准备为顾客理发
	V(mutex);                     
		//退出临界区
	cut_hair(); 
	//理发师正在理发(非临界区)
 	}
}

process customer_i( ) {
 P(mutex);
	if(waiting<CHAIRS) {     
		//有空椅子吗
		waiting++;  //等候顾客数加1
 		V(customers);  //唤醒理发师
		V(mutex);      //退出临界区
		P(barbers);  
			//理发师忙，顾客坐下等待
		get_haircut(); //否则顾客坐下理发
   	}
 	else  V(mutex); //人满了,走吧！
 }
```

> **生产者-消费者模型**的一个变体
>
> 在单次任务中，理发师先**等待顾客**，如果顾客没有来，理发师就在睡觉。
>
> ```c
> P(consumers);
> ```
>
> 然后，如果等到了一个顾客来了，理发师就要更新缓冲区状态了，把正在等待理发的顾客数目-1，先进行加锁互斥。
>
> ```c
> P(mutex);
> waiting --;
> ```
>
> 然后理发师睡起来了，**准备开始理发**了。
>
> ``` c
> V(barber);
> ```
>
> 因为理发操作，所需花费的时间是很长的，这里不能放在临界区去执行。理发师理发前，先解锁，离开临界区。
>
> ```c
> V(mutex)
> cut_hair();
> ```
>
> 同样，再考虑顾客的任务，对于顾客来说，每次来的一个顾客就是一个单独的任务。
> 首先，顾客来了，要判断现在还有没有位置可以坐下，如果没有，就直接走了。(当然这里少不了临界区管理)
>
> 然后，每个顾客来之后，如果发现现在还有位置坐，就先坐下来，然后正在等待的顾客数量+1，并且告诉理发师，现在有顾客来了，**唤醒理发师**。
>
> ```c
> waiting = waiting+1;
> V(customers); 
> ```
>
> 然后就**阻塞在顾客等待理发的队列上**，等待理发师理发。
>
> ```c
> P(barbers); 
> ```

### **农夫猎人问题**

有一个铁笼子，每次只能放入一个动物。猎手向笼中放入老虎，农夫向笼中放入羊；动物园等待取笼中的老虎，饭店等待取笼中的羊。

> 典型的苹果-橘子问题，不多说

### **银行业务问题**

某大型银行办理人民币储蓄业务，由n个储蓄员负责。每个顾客进入银行后先至取号机取一个号，并且在等待区找到空沙发坐下等着叫号。取号机给出的号码依次递增，并假定有足够多的空沙发容纳顾客。当一个储蓄员空闲下来，就叫下一个号。

```c
 customer_count=0; server_count=0; mutex=1; 

process customer_i (i=1,2, …)
begin
 	take a number;
 	P(mutex);
		等待区找到空沙发坐下;
 	V(mutex);
 	V(customer_count);	// 拿到号了
 	P(server_count);	// 是否已满，排队
end;

Process servers_j (j=1,2, …)
begin
 	L: P(customer_count);	// 叫下一位
 		P(mutex);
			被呼号顾客离开沙发走出等待区;
 		V(mutex);
		V(server_count);	// 服务完，该储蓄员空闲
		为该号客人服务;
		客人离开;
 	go to L;
end;
```

> 和睡眠的理发师问题一样，只不过这次理发师（储蓄员）有多个，但是这个多个体现在进程多可能并行，不影响代码结构。代码几乎和理发师模型一样。
>
> 还是要注意长时间作业尽量不要放临界区里。

### **缓冲区管理**

有n个进程将字符逐个读入到一个容量为80的缓冲区 中(n>1)，当缓冲区满后，由输出进程Q负责**一次性取走**这80个字符。

```c
count,in:integer
buffer:array[0..79] of char;
mutex=1;empty=80;full=0;
count=0;in=0;

process Pi(i=1,...,n))
begin
 	L: 读入一字符到 x;
	P(empty);
		P(mutex);
 			Buffer[in]=x;
 			in=(in+1) % 80;
 			count++;
 			if (count==80)  {	// 直到满80再full++
 				count=0; 
                V(mutex); 
                V(full);  
            }else 
            	V(mutex);
    goto L;
 end;

process Q
begin
 	while(true) {
 		P(full);
 		P(mutex);
 		for(int j=0; j< 80;j++) 
				read buffer[j];
 		in=0;
		V(mutex);
 		for (int j=0; j< 80;j++) 
				V(empty);		// ！empty要释放80次返回初值
 	}
end;
```

> 依然是交叉式的生产者-消费者模型，只不过加了限制条件。根据条件设置信号量值。

### **售票问题**

汽车司机与售票员之间必须协同工作，一方面只有售票员把车门关好了司机才能开车，因此，售票员关好门应通知司机开车，然后售票员进行售票。另一方面，只有当汽车已经停下，售票员才能开门上下客，故司机停车后应该通知售票员。假定某辆公共汽车上有一名司机与两名售票员，汽车当前正在始发站停车上客。

```c
run1=0; run2=0; stop1=0; stop2=0;

void Driver() {
   while (true) 
   {
       P(run1); 	// 确认售票员1处门是否关好
       P(run2); 	// 确认售票员2处门是否关好
       开车; 
       停车; 
       V(stop1); 	// 通知售票员1停车了
       V(stop2); 	// 通知售票员2停车了
     }
 }
 
void Seller_i() {	// i = 1,2
   while (true)   {
       上乘客; 
       关车门; 
        V(runi); 	// 售票员i通知司机门关好了
        售车票; 
       P(stopi); 	// 确认司机有没有通知自己停车了
        开车门; 
        下乘客; 
     }
 } 
```

> 简单的同步问题

### **吸烟者问题**

三个吸烟者在一个房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴， 供应者有丰富货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸和第三个有自己的火柴。供应者随机地将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者， 供应者再把两样东西放在桌子上，唤醒另一个吸烟者。

```c
sput=1;sget[i]=0; //i=0, 1, 2

Process businessman {        
//供应者进程
L1:	 i=RAND( ) mod 3;
 	 j=RAND( ) mod 3;
 	 If  (i==j)  then goto L1;
 	 
 	 P(Sput);
 	 Put_items [i]_on_table;
 	 Put_items [j]_on_table;
 	 if (i=0 and j=1) or (i=1 and j=0) V(sget[2]);
 	 if (i=1 and j=2) or (i=2and j=1)  V(sget[0]);
 	 if (i=0 and j=2) or (i=2 and j=0) V(sget[1]);
 goto L1;
}

Process consumer (k) {    
//吸烟者进程，k=0,1,2
L2：
	P(sget[k]);
 	take_one_item_from_table;
 	take_one_item_from_table;
 	V(sput);
 	make_cigarette_and_smoking
 goto L2;
}
```

> 题目很复杂，代码很简单。也是生产者-消费者问题的变种，只不过**生产者会选择消费者**。

## ⭐⭐**管程**
