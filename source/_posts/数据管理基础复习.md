---
title: 数据管理-review
date: 2025-06-03 19:50:01
categories:   "课程复习"
tags: [数据管理]
toc : true
cover: "1748952500871-4.png"
---

# 一、计算、数据与数据管理

## 基本概念

**计算** = 算法 + 数据

**数据结构** （ 数组，链表，堆，栈，树，图…… ）

**⭐数据管理：**

| 类型     | 管理者                     | 对象         | 共享程度           | 独立性               | 结构化                   | 控制能力         |
| -------- | -------------------------- | ------------ | ------------------ | -------------------- | ------------------------ | ---------------- |
| 人工管理 | 用户（程序员），数据不保存 | 某一应用程序 | 无共享、冗余度极大 | 不独立，完全依赖程序 | 无结构                   | 应用程序自己控制 |
| 文件系统 | 文件系统，数据可长期保存   | 某一应用程序 | 共享性差、冗余度大 | 独立性差             | 记录内有结构，整体无结构 | 应用程序自己控制 |

共享数据：

- 基于二进制在多个应用之间共享数据；
- 基于文本在多个应用之间共享数据（K/V, JSON, XML）

**数据（Data）**是数据库中存储的基本对象，是描述事物的符号记录。（数字、文字、音频…）

数据的含义称为数据的**语义**，**数据与其语义是不可分**的。

## 数据库

==数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合==

> 数据库接受应用的委托，统一完成相关任务。不需要应用自己实现文件的增删改查。

**数据库系统（Database System，简称DBS）**，在计算机系统中引入数据库后的系统构成

**数据库管理系统（DBMS）**是位于用户与操作系统之间的一层数据管理软件，用于科学地组织和存储数据、高效地获取和维护数据。

==⭐数据库的特点==

1. **数据结构化**
   1. **整体**结构化
      1. **面向全组织**，不针对某个应用
      2. 不仅数据**内部结构化**，**整体也是结构化**的，数据间有**联系**
      3. 数据记录可以**变长**
      4. 数据的**最小存取单位**是**数据项**
   2. 数据**用数据模型描述**，无需应用程序定义
2. 数据的**共享性高**，**冗余度低**且**易扩充**
   1. 数据面向整个系统，可以被多个用户、多个应用共享使用。
3. 数据**独立性高**
   1. **物理**独立性
   2. **逻辑**独立性
   3. 数据独立性由DBMS的**二级映像**功能来保证。
4. 数据由数据管理系统**统一管理和控制**
   1. **安全**性保护
   2. **完整**性检查
   3. **并发**控制
   4. 数据库**恢复**

> 数据共享的好处：
>
> 1. 减少数据冗余
> 2. 避免数据之间的不相容和不一致
> 3. 使系统易于扩充
>
> 独立性：指用户的应用程序与数据库的物理(逻辑)结构是相互独立的。数据的物理(逻辑)结构改变了，应用程序不用改变。

**数据库系统的构成**：DB、DBS(及其应用开发工具)、应用程序、数据库管理员(DBA)

### 数据库管理系统的主要功能

1.  **数据定义功能**
   - 提供**数据定义语言（DDL）**
   - 定义数据库中的数据对象
2.  **数据组织、存储和管理**
   - **分类**组织、存储和管理各种数据
   - 确定组织数据的**文件结构**和**存取方式**
   - 实现数据之间的**联系**
   - 提供多种**存取方法**提高存取效率
3.  **数据操纵功能**
    - 提供**数据操纵语言（DML）**
    - 实现对数据库的基本操作 （查询、插入、删除和修改）
4.  **数据库的事务管理和运行管理**
    - DB的**建立、运行和维护**由DBMS统一管理
    - 保证数据的**安全性、完整性、并发**
    - 发生**故障**后的系统**恢复**
5.  **数据库的建立和维护功能**
    - 初始数据的**装载和转换**
    - **转储、恢复**功能
    - DB的**重组织**
    - **性能**监视、分析等
6.  **其他功能**
    - DBMS与网络中其它软件系统的**通信**
    - DBMS之间的**数据转换**
    - 异构DB之间的**互访和互操作**

## 数据模型

数据模型是对现实世界数据特征的抽象，用以==抽象、表示和处理==现实世界中的数据和信息。**数据模型是数据库系统的核心和基础**。

有**概念/逻辑/物理**三类模型。

### ⭐两步抽象

1. ==现实世界中的客观对象抽象为概念模型==
   - 现实世界  ->  信息世界
2. ==把概念模型转换为特定DBMS支持的数据模型==
   - 信息世界  ->  机器世界

​	<img src="数据管理基础复习/1748949243018-1.png" alt="img" style="zoom:50%;" />

### 数据模型的组成要素

1. **数据结构**
   - 描写数据库的组成对象，以及对象之间的联系
   - 数据结构是对**系统静态特性**的描述
2. **数据操作**
   - 对各种对象（型）和实例（值）的允许执行的操作集合（**增删改查**），包括操作和相关的操作规则
   - 数据操作是对**系统动态特性**的描述

3. **数据的完整性约束条件**
   - 一组完整性规则的集合
   - **完整性规则**：给定的数据模型中数据及其联系所具有的 制约和依存规则

### 概念模型

用于**信息世界**的建模，是现实世界到机器世界的一个中间层次。

#### 概念模型的基本概念

1. **实体（Entity）**：客观存在并可相互区别的事物
2. **属性（Attribute）**：实体所具有的某一特性
3. **码（Key）**：唯一标识实体的**属性集**
4. **实体型（Entity Type）**：用<u>实体名及其属性名集合</u>来抽象和刻画同类实体
5. **实体集（Entity Set）**：同一类型实体的集合
6. **联系（Relationship）**：**实体（型）内部的联系**和**实体（型）之间的联系**

#### 联系

1. **实体之间**的联系：**不同实体集**之间的联系，有一对一、一对多和多对多等。

2. **实体内部**的联系：通常是指组成实体的各**属性**之间的联系。

#### 实体-联系方法（E-R方法）

​	实体：方框、属性：椭圆、联系：菱形

​	<img src="数据管理基础复习/image-20250603195243763.png" alt="image-20250603195243763" style="zoom: 33%;" />

### 逻辑模型

**信息世界转换为机器世界**：

	1. 尽量独立于应用层，采用“中立”的方式表达概念模型
	1. 在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构

通用数据结构采用方案1，关键性数据结构采用方案2

#### 常用数据模型

1. 格式化模型
   1. 层次模型
   2. 网状模型
2. 关系模型
3. 对象模型
   1. 面向对象数据模型
   2. 对象关系数据模型

#### 关系模型的数据结构

1. **关系（Relation）**：一个关系对应通常说的一张**表**
2. **元组（Tuple）**：表中的一行即为一个元组
3. **属性（Attribute）**：表中的一列即为一个属性
4. **主码（Key）**：也称码键。表中的某个属性组，它可以唯一确定一个元组。
5. **域（Domain）**：是一组具有相同数据类型的值的集合。
6. **分量**：元组中的一个属性值。

> 关系必须是**规范化**的。最基本的：关系的每一个分量必须是一个不可分的数据项，不允许**表中有表**。

#### 关系模型的操作与完整性约束

- 数据操作是集合操作

- 存取路径对用户隐蔽

关系的完整性约束条件：

1. 实体完整性
2. 参照完整性
3. 用户定义的完整性

关系模型的优点：严格的数学概念；概念单一；存取路径透明。

关系模型的缺点：存取路径透明，**查询效率**往往不如格式化数据模型；增加了开发DBMS的难度。

#### NoSQL

**非关系型**的数据库，一般用于**超大规模**数据的存储。



## 数据库系统的结构

对于应用开发人员：**三级模式结构**

### ⭐模式和实例

**模式（Schema）**：数据库逻辑结构和特征的描述（型的描述）。

**实例（Instance）**：数据库某一时刻的状态（值）；同一个模式可以有很多实例。

### ⭐三级模式结构

​	==对数据的三个抽象级别==

<img src="数据管理基础复习/1748952500871-4.png" alt="img" style="zoom:33%;" />

#### 模式（逻辑模式）

​	数据库中**全体数据的逻辑结构和特征**的描述，所有用户的**公共数据视图**。

​	一个数据库只有**一个**模式

​	模式的**地位**：是数据库系统模式结构的**中间层**

​	**模式定义了数据的逻辑结构、联系、有关安全性完整性要求**

#### 外模式（子模式、用户模式）

​	数据库**用户**（包括应用程序员和最终用户）使用的**局部数据的逻辑结构和特征**的描述。

​	数据库**用户的数据视图**，是与**某一应用**有关的数据的逻辑表示。

​	外模式的**地位**：介于模式与应用之间

​	外模式的**用途**：**安全性**（用户只能看见和访问外模式的数据）

> **模式与外模式：一对多**。外模式通常是模式的子集，反应用户的不同需求、看待数据的方式、 对数据保密的要求。
>
> **外模式与应用：一对多**。同一外模式可以被多用，但一个应用程序只能有一个外模式。

#### 内模式（存储模式）

​	数据**物理结构和存储方式**的描述，是数据在**数据库内部**的表示方式（存储方式、加密、压缩……）

​	一个数据库只有**一个**内模式

### ⭐二级映像

​	==三个抽象层次的联系和转换==

​	**外模式／模式 映像**：每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系，保证数据的**逻辑独立性**。通常包含在**各自外模式的描述**。

> 当模式改变时，数据库管理员对外模式／模式映象作相应改变， **使外模式保持不变**。这样基于外模式的应用程序也就不用改变。

​	**模式／内模式 映象**：定义了数据全局逻辑结构与存储结构之间的对应关系。**唯一的**。通常包含在**模式描述**。保证数据的**物理独立性**。

> 当数据库的存储结构改变了， 数据库管理员修改模式／内模式映象，**使模式保持不变**。应用程序不受影响。

==模式、内模式、外模式、应用程序、存储设备关系总结==

1. 设计DB模式结构时，**首先确定模式（逻辑模式）**，即全局逻辑结构，它**独立于所有其他层次**。

2. 内模式**依赖于模式**，**独立于外模式和具体的存储设备**，按照一定的物理存储策略组织模式定义的数据结构。
3. 外模式**定义在模式上**，**独立于内模式和存储结构**，面向应用程序，随应用需求变化，要考虑**扩充性**。
4. 应用程序**依赖于特定的外模式**，**独立于模式和存储结构**，不同程序有时可以共用一个外模式。

> 二级映像保证了数据库**外模式的稳定性**，进而从底层保证了应用程序的稳定性。数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去。数据的存取由数据库管理系统管理大大简化了应用程序的编制、维护和修改。

## 数据库系统的组成

1. 软硬件平台
2. 人员（管理员、系统分析员和数据库设计人员、应用程序员、最终用户）



# 二、关系、关系模式和关系数据库

## 关系的基本概念

### 笛卡尔积

1. **域（Domain）**：一组具有相同数据类型的值的集合。
2. **笛卡尔积（Cartesian Product）**：**所有域**的**所有取值**的一个**组合**
3. **元组（Tuple）**：笛卡尔积中每一个元素，也是关系的每一个元素
4. **分量（Component）**：一个元组的每一个值
5. **基数（Cardinal number）**：元素个数。$M = \sum^n_{i=1}m_i$，其中 $m_i$为$D_i$的基数。
6. **关系（Relastion）**：笛卡尔积的子集
7. **目**：属性列（分量）数

>  笛卡尔积（关系）可以用**二维表**表示。

### 码

- **候选码**：能唯一地标识一个元组的**最小属性组**。若为全属性即为**全码**。
- **主码**：从候选码里选一个。
- **主属性**：候选码的属性。

### 关系

- 基本关系（基本表）：实际存在的表
- 视图表：**虚表**，由基本表或者其他视图表导出。

## 关系模式

==关系模式（Relation Schema）是型，关系是值==，关系模式是对关系的描述（元组结构和完整性约束条件）
$$
R（U，D，DOM，F）
$$
R关系名，U属性名集合，D属性来自的域，DOM属性向域的映像集，F属性间数据的依赖关系的集合

> 域名及属性向域的映象常常直接说明为属性的类型、长度

关系模式通常可以简记为$R (U)$或$R (A_1，A_2，…，A_n)$，其中$A_1，A_2，…，A_n$就是属性名

在一个给定的应用领域中，**所有关系的集合构成一个关系数据库**

## 关系的完整性约束

### 实体完整性

现实世界中的实体是**可区分**的：**主属性不取空值**

### 参照完整性

> **外码**
>
> 设F是基本关系R的一个或一组属性，但<u>不是关系R的码</u>。如果<u>F与基本关系S的**主码**Ks相对应</u>，则称F是R的外码。
>
> - 基本关系R称为参照关系
> - 基本关系S称为被参照关系
>
> 关系R和S不一定是不同的关系；Ks和F必须在**同一域**。Ks和F不一定同名。

若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须为**空值或S中某个元组的主码值**。

### 用户定义的完整性

某一**具体应用**所涉及的数据必须满足的语义要求

## 关系代数

### 常用操作

1. **查询：<u>选择、投影、并、差、笛卡尔积</u>、连接、除、交**（画线的是笛卡尔积的5个基本操作）
2. **数据更新：插入、删除、修改**

操作对象和结果都是**集合**

### ⭐关系代数运算

一种抽象的**查询语言**

​	<img src="数据管理基础复习/image-20250603212751944.png" alt="image-20250603212751944" style="zoom:33%;" />

- **并、交、差**：很好理解
- **笛卡尔积**：简单来说，就是R中每个元组和S中每个元组**排列组合**，首尾拼接成一个更长的元组，形成新的集合。

一些常用记号：

- $t[A_i]$表示元组t中相应于属性$A_i$的一个分量；$A$是$A_i$的集合，那么$t[A]$就是$t[A_i]$的集合。
- $\overset{\frown}{t_rt_s}$连接元组$t_r$和$t_s$
- $A=\{ A_{i1} , A_{i2} , ... , A_{ik}\}$，$\overline{A}$$表示$$\{A_1,A_2,...，A_n \}$$中去掉$$\{ A_{i1} , A_{i2} , ... , A_{ik} \}$后剩余的属性组

==象集==

​	关系$R(X,Z)$，X和Z为两个属性组。$Z_x=\{t[Z]|t \in R，t[X]=x \}$为x在R中的**象集(Image Set)**

> 笼统的说，如果x是属性X的一种取值，那么x的象集$Z_x$就是 **所有属性X的值为x的元组 在属性Z上的取值的集合**，象集的结果是一个**一维**的集合，元素是**属性Z的取值**。 

==选择σ==
$$
σ_F(R) = \{t|t \in R ∧ F(t)= 真 \}
$$
​	F是条件，R是关系。$σ_F(R)$就是选取 **使条件F为真的诸元组**

> 这样的表达有些奇怪…我一开始以为选择只产生元组，不产生关系（虽然满足关系定义）。后来发现：**选择（σ）不改变属性结构，只减少元组数量；它天然输出新关系。**
>
> 所以先投影再选择和先选择再投影应该是等价的（当然这里不考虑选择条件的属性会被投影删除）

==投影$\pi$==
$$
π_A(R) = \{ t[A] | t  \in R \}
$$
​	A是R中的属性列，$π_A(R)$表示**从R中选择A属性列组成新的关系**

> 投影之后不仅取消了原关系中的某些列，而且还可能**取消某些元组（避免重复行）**

==连接==
$$
R \underset{A \theta B}{\bowtie} S = \{ \overset{\frown}{t_rt_s} |t_r \in R ∧ t_s \in S ∧ t_r[A] \theta t_s[B]\}
$$
$\theta$表示运算，A和B分别是R和S上的属性组，表示**从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组**。

> **等值连接**：$\theta $为 “=”
>
> **自然连接**：$\theta $为 “=” 且 A和B为**相同属性组**，并在结构中取消重复的属性列（A、B只保留一个）

​	简单的说，**连接**就是先构建笛卡尔积R×S，然后从这个R×S里选择满足 “ <u>A的值 $\theta$ B的值</u> ” 这个等式的元组构成新关系。

​	当然，为了便于区分，一般不会直接指明A或B，而是说R.A和S.B。

​	另外，**连接**不满足交换律，$R\bowtie S$ 和 $S \bowtie R$ 一般是不一样的。 $R\bowtie S$是S去连接R，**S中无法连接上的元组会被舍弃**。

**悬浮元组**：无法连接上的被舍弃的元组会成为**悬浮元组**，要保留这些悬浮元组就需要**外连接**。

==外连接==

​	**在自然连接的基础上**，把悬浮元组也保存在结果关系中，而在其他属性上填**空值(Null)**，就叫做外连接

- 左外连接：只保留左边关系R中的悬浮元组（⟕）
- 右外连接：只保留右边关系S中的悬浮元组（⟖）
- 全外连接（书上没有）：保留所有悬浮元组（⟗）

==除运算==

关系R(X，Y)和S(Y，Z)，Y为R和S的共有属性组（可能多个）
$$
R÷S=\{t_r[X]|t_r\in R∧π_Y(S) \subseteq Y_x\}
$$
结果：R中属性X的值x的集合

条件：**这个x的象集$Y_x$应当能包含S中属性组Y的所有值**

例子：

​	<img src="数据管理基础复习/1748963030251-7.png" alt="img" style="zoom:33%;" />

​	<img src="数据管理基础复习/1748963040347-10.png" alt="img" style="zoom:33%;" />

> 从实际含义的角度来直白的解释除运算：
>
> 首先搞清楚**象集**的实际含义。一个关系表里的某个属性列的取值可能存在相同的情况，比如说我说一个学生选课表，学生选的课不只一门，那么在这个选课表里该学生的学号应该就出现了不止一次，类似:
>| 学号Sno   | 选课号Cno |
> | --------- | --------- |
> | 231250032 | 1         |
> | 231250032 | 2         |
> | …         | …         |
> 
> 那么**象集** ${选课号}_{学号}$ 就是指**课程号的集合**{1,2,……}，也就是**该学号关联的所有选课的取值**。
>
> 而**除运算**，就是我有一个新的关系表（除数），它的某些属性列和原来的关系表（被除数）有重合。除运算的目的，就是挑选出与被除数表中，那些**关于重合属性列的象集 能够完全包含除数里重合属性列的所有取值 的某属性的 取值集合**。
>
> 同样是学生选课表**R(Sno,Cno)**，定义一个临时表K：**| Cno | 1 | 2 |**， 那么R÷S就是找到**哪些学生至少选了1号和2号课程**。
>$$
> \pi_{Sno,Cno}(R)÷K = \{...\}
> $$
> 
> 从这个角度讲，除运算本质上是一种”**选择-包含**“运算。

# 三、SQL概述

==SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言==

## SQL的特点

1. **综合统一**
   1. 集数据**定义**语言（DDL），数据**操纵**语言（DML），数据**控制**语言（DCL）功能于一体。
   2. 可以独立完成**数据库生命周期中的全部活动**
   3. 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行。
   4. 数据操作符统一。
2. **高度非过程化**
   1. 非关系数据模型的DML是过程化的，要**指定存取路径**；SQL不需要，会**自动完成**。
3. 面向**集合**的操作方式
   1. 非关系数据模型采用面向记录的操作方式，SQL面向集合
   2. 操作对象、查找、更新的对象和结果都可以是集合
4. 以同一种**语法结构**提供**多种使用**方式
   1. SQL既是独立语言，又是嵌入式语言
5. 语法简洁，易学易用

**SQL与三级模式结构**

- **基本表 -> 模式**
  - 独立存在的表
  - 对应**一个**关系和**若干索引**
- **存储文件 ->  内模式**
  - 逻辑结构组成内模式
  - 物理结构**隐蔽**
- **视图 -> 外模式**
  - 由基本表导出，**虚表**
  - 可以在之上再定义视图

## SQL数据定义

层次化的数据库对象命名机制：一个关系型数据库管理系统的实例可以建立多个数据库；**一个数据库可以建立多个模式**；**一个模式包括多个表、视图、索引等**。

![image-20250604163200505](数据管理基础复习/image-20250604163200505.png)

### 模式定义

定义模式实际上定义了一个**命名空间**，在这个空间可以定义该模式包含的数据库对象。

```sql
CREATE SCHEMA <模式名> 	/*如果不指定模式名，隐含为用户名*/
AUTHORIZATION <用户名>  	/*所属用户*/
[<表定义子句>|<视图定义子句>|<授权定义子句>]		/*可以定义数据库对象*/

DROP SCHEMA <模式名> <CASCADE|RESTRICT>	/*删除模式*/
```

> **CASCADE**：**级联**，删除模式的同时把该模式中所有的数据库对象全部删除。
>
> **RESTRICT**：**限制**，如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。

### 基本表定义

```sql
CREATE TABLE <表名>
 (<列名> <数据类型>[ <列级完整性约束条件> ]
 [,<列名> <数据类型>[ <列级完整性约束条件>] ] 
	…
 [,<表级完整性约束条件> ] )
```

> **数据类型(域)表**：
>
> ​	<img src="数据管理基础复习/image-20250604163803559.png" alt="image-20250604163803559" style="zoom:50%;" />
>
> 列级完整性约束条件：NotNull，PrimaryKey……
>
> 表级完整性约束条件：ForeignKey，PRIMARY KEY(A,B)……

```sql
ALTER TABLE <表名>
 [ ADD [ COLUMN ] <新列名> <数据类型> [ 完整性约束] ]	/*增加新列、新的列级完整性约束条件*/
 [ ADD <表级完整性约束>]		/*增加新的表级完整性约束条件*/
 [ DROP [ COLUMN ] <列名> [CASCADE | RESTRICT] ]		/*删除列*/
 [ DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ] ]	/*删除完整性约束条件*/
 [ ALTER COLUMN <列名><数据类型> ] ;	/*修改数据类型*/
 [ RENAME COLUMN supplier_name to sname; ]	/*修改列名*/
```

```sql
DROP TABLE <表名>［RESTRICT| CASCADE］;
```

> **CASCADE**：在删除基本表的同时，相关的依赖对象一起删除.
>
> **RESTRICT**：如果该表有被引用或依赖，则拒绝执行。

### 索引

建立索引的目的：**加快查询速度**

DBMS自动选择合适的索引作为存取路径，用户无法干涉。常见索引：

1. 顺序文件上的索引
2. B+树索引
3. 散列（hash）索引
4. 位图索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
 ON <表名> (<列名>[<次序>]		/*索引可以建立在该表的一列或多列上*/
          [,<列名>[<次序>] ]…);
          
ALTER INDEX <旧索引名> RENAME TO <新索引名>

DROP INDEX <索引名>;
```

> **UNIQUE**：此索引的每一个索引值只对应唯一的数据记录
>
> **CLUSTER**：表示要建立的索引是**聚簇索引**
>
> **<次序>**：指定索引值的排列次序，**升序：ASC**，**降序： DESC**。缺省值：ASC。

```sql
CREATE UNIQUE INDEX  SCno ON SC(Sno ASC,Cno DESC);
```

### **数据字典**

​	关系数据库管理系统内部的一组系统表，它记录了数据库中所有**定义信息**。执行定义语句就是在更新数据字典。

## SQL数据查询

### SQL数据查询（单表）

####  单表查询语法

```sql
SELECT [ALL|DISTINCT] <目标列表达式>[,<目标列表达式>] …		/*目标表达式也可以是算术表达式*/
FROM <表名或视图名> [, <表名或视图名> ] … | (SELECT 语句) [AS] <别名>	/*嵌套*/
[ WHERE <条件表达式> ]					
[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
[ ORDER BY <列名2> [ ASC|DESC ] ];		/*升序：ASC;降序：DESC;缺省值为升序*/
```

> **GROUP BY**子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。
>
> **HAVING**短语：只有满足指定条件的组才予以输出.
>
> **DISTINCT**：去除重复值。如果没有指定DISTINCT关键词，则缺省为ALL（不删除重复）。

#### 查询经过计算的值

```sql
SELECT Sname,2014-Sage FROM Student;
SELECT Sname,'Year of Birth: ',2014-Sage,LOWER(Sdept) FROM Student;
/*会在结果添加一整列值都为'Year of Birth: '的列*/
SELECT SnameNAME,'Year of Birth:' BIRTH,2014-Sage BIRTHDAY,LOWER(Sdept) FROM Student;
/*给2014-Sage起别名BIRTHDAY，改变查询结果的列标题*/
```

#### 查询条件

<img src="数据管理基础复习/image-20250604185421528.png" alt="image-20250604185421528" style="zoom: 50%;" />

```sql
WHERE Sage<20;
WHERE Sage BETWEEN 20 AND 23; 
WHERE Sdept IN ('CS','MA','IS' );	/* IN <值表> */
```

```sql
[NOT] LIKE  ‘<匹配串>’  [ESCAPE ‘ <换码字符>’]

WHERE  Sno LIKE '201215121';
WHERE  Sname LIKE '刘%';
WHERE  Sname LIKE '欧阳__';
WHERE  Cname LIKE 'DB\_Design' ESCAPE '\ ' ;
```

> 通配符**%**（任意长度 *（长度可以为0）*的字符串）：a%b表示以a开头，以b结尾的任意长度的字符串。
>
> 通配符**_** （任意**单个**字符）：a_b表示以a开头，以b结尾的长度为3的任意字符串。
>
> 使用换码字符将通配符转义为普通字符，**ESCAPE** '＼' 表示“ ＼” 为换码字符

```sql
WHERE  Grade IS NOT NULL;
WHERE Sdept= 'CS' AND Sage<20;
```

#### 聚集函数

```sql
SELECT COUNT(*) FROM Student;
SELECT COUNT(DISTINCT Sno) FROM SC;
SELECT AVG(Grade) FROM SC WHERE Cno='1';
SELECT MAX(Grade) FROM SC WHERE Cno='1';
SELECT SUM(Ccredit) FROM SC,Course WHERE SC.Cno=Course.Cno; 
```

#### 对查询结果分组

GROUP BY子句分组：**细化聚集函数的作用对象**

如果未对查询结果分组，聚集函数将作用于整个查询结果；对查询结果分组后，聚集函数将分别作用于每个组。

按指定的一列或多列值分组，**值相等的为一组**。

```sql
SELECT Cno，COUNT(Sno) FROM SC GROUP BY Cno;	/*求各个课程号及相应的选课人数*/
SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)>3; /*查询选修了3门以上课程的学生学号*/
```

> HAVING短语与WHERE子句的区别：WHERE子句作用于基表或视图，HAVING短语作用于组。
>
> WHERE子句中是不能用聚集函数：`WHERE AVG(grade)>90 `是错误的。
>
> ```sql
> SELECT Sno, AVG(Grade) FROM SC WHERE AVG(Grade)>=90 GROUP BY Sno;/*Wrong!*/
> SELECT  Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)>=90;
> ```

### SQL数据查询（连接）

#### 连接操作

**连接查询**：同时涉及两个以上的表的查询

**连接条件**或连接谓词：用来连接两个表的条件

**连接字段**：连接谓词中的列名称。连接字段必须可比。

```sql
 WHERE Student.Sno=SC.Sno;
```

> 连接操作的执行过程：
>
> 1. 嵌套循环法（NESTED-LOOP）：双重循环遍历
> 2. 排序合并法（SORT-MERGE）：先排序再遍历（常用于=连接）
> 3. 索引连接（INDEX-JOIN）：对表2按连接字段建立索引，遍历表1找到符合的并拼接

#### 选择和连接

一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由**连接谓词和选择谓词组成的复合条件**。

```sql
SELECT Student.Sno, Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno AND    
	  SC.Cno='2' AND SC.Grade>90;
```

**自身连接**：要使用别名

```sql
SELECT FIRST.Cno, SECOND.Cpno 
FROM Course FIRST, Course SECOND
WHERE FIRST.Cpno = SECOND.Cno;
```

 **外连接**：

```sql
SELECT Student.*
FROM  Student  LEFT OUT JOIN SC ON    
(Student.Sno=SC.Sno);
```

**多表连接**：

```sql
SELECT Student.Sno, Sname, Cname, Grade
FROM  Student, SC, Course    /*多表连接*/
WHERE Student.Sno = SC.Sno
	AND SC.Cno = Course.Cno;
```

### SQL数据查询（嵌套）

不是很重要，嵌套查询使用要谨慎，**能用连接运算替代的就用连接**（考试对嵌套不做要求，默认都可以用表连接完成）

```sql
SELECT Sno, Cno
FROM    SC x
WHERE Grade >= (SELECT AVG（Grade）
				FROM  SC y
 				WHERE y.Sno=x.Sno);
 				
SELECT Sname,Sage
FROM Student
WHERE Sage < ALL
 			(SELECT Sage FROM Student
 				WHERE Sdept= ' CS ')
 		AND Sdept <> ' CS ';
 				
SELECT Sname
FROM Student
WHERE NOT EXISTS
 		(SELECT * FROM SC
 		WHERE Sno= Student.Sno AND Cno='1');
```

> 嵌套查询前也可以加ALL表示与全部数据比较，也可以加EXISTS表示存在谓词

### SQL数据查询（集合）

集合操作的种类

- 并操作UNION
- 交操作INTERSECT
- 差操作EXCEPT

参加集合操作的各查询结果的**列数**必须相同；对应项的**数据类型**也必须相同

#### 并操作

**UNION**：将多个查询结果合并起来时，系统**自动去掉重复元组**。

UNION **ALL**：将多个查询结果合并起来时，**保留重复元组**。

```sql
(SELECT ... ) UNION (SELECT ...)
```

#### 交操作

与并同理

```sql
(SELECT ... ) INTERSECT (SELECT ...)
```

#### 差操作

表示左查询结果去掉右查询结果的**差集**。

```sql
(SELECT ... ) EXCEPT (SELECT ...)
```

### SQL数据查询（基于派生表）

子查询不仅可以出现在WHERE子句中，还可以出现在**FROM子句**中，这时子查询生成的**临时派生表（Derived Table）**成为 主查询的查询对象。

```sql
SELECT Sno, Cno
FROM SC, (SELECT Sno, Avg(Grade)
 			FROM SC
 			GROUP BY Sno)
 				AS  Avg_sc(avg_sno,avg_grade)	/* 指定属性列 */
WHERE SC.Sno = Avg_sc.avg_sno
 	and SC.Grade >=Avg_sc.avg_grade
```

如果子查询中**没有聚集函数**，派生表可以不指定属性列，子查询**SELECT子句后面的列名**为其缺省属性。

## SQL数据更新

### SQL数据更新-插入

**插入元组**：将新元组插入指定表中

```sql
INSERT INTO <表名> [(<属性列1>[,<属性列2 >…)]
VALUES (<常量1> [,<常量2>]… );
```

> 不指定属性列时，表示插入完整元组；指定属性列时，未指定属性列置空值。

**插入子查询结果**：

```sql
INSERT 
INTO <表名>  [(<属性列1> [,<属性列2>…  )]
子查询;
```

> SELECT子句目标列必须与INTO子句匹配

### SQL数据更新-修改

```sql
UPDATE  <表名>
SET  <列名>=<表达式>[,<列名>=<表达式>]…
[WHERE <条件>];
```

> 不指定WHERE表示全局修改

```sql
UPDATE  Student
SET Sage=22
WHERE  Sno=' 201215121 '; /*将学生201215121的年龄改为22岁*/
```

> 修改要注意**完整性约束**

### SQL数据更新-删除

```sql
DELETE
FROM  <表名>
[WHERE <条件>]; /* 如果WHERE缺省，删除全部元组，但保留表的定义*/
```

## SQL中的空值

基本的：

- 空值要特殊处理
- 用IS NULL或IS NOT NULL判断
- NOT NULL、UNIQUE、码属性不能取空值

**空值的运算**

- 空值与另一个值（包括另一个空值）的**算术运算**的结果为**空值**
- 空值与另一个值（包括另一个空值）的**比较运算**的结果为**UNKNOWN**

**带UNKNOWN的三元真值运算**

​	<img src="数据管理基础复习/image-20250604231705815.png" alt="image-20250604231705815" style="zoom:33%;" />

## 视图

 **虚表**，是从一个或几个基本表（或视图）导出的表，因此，视图存放的只是定义而不是数值，这意味着如果基表的数值改变，视图中的数值也会跟着改变。

### 建立视图

```sql
CREATE  VIEW 
<视图名>  [(<列名>  [,<列名>]…)]	/*要么全省要么指定所有列名*/
AS  <子查询>
[WITH  CHECK  OPTION];
```

> **[WITH  CHECK  OPTION]**：保证对视图更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）
>
> 如果子查询多表连接存在**重名**属性，或者存在**聚集函数**，要在视图中启用新名字。

DBMS执行该语句时，不会真的去做查询，只是保存视图的定义，用到时再做查询。

若一个视图是从**单个基本表**导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为**行列子集视图**

###  删除视图

```sql
DROP  VIEW  <视图名>[CASCADE];	/*级联把在它之上定义的视图都删了*/
```

### 查询视图

视图消解法（View Resolution）：转换成等价的对基本表的查询。

有时，试图消解法会产生错误，典型的就是对于有GROUP BY的查询，要用HAVING不能用WHERE。

其他情况下查询视图与查询基本表相同。

### 更新视图

修改、添加、删除数据

转换成**对基本表的更新**，语法相同

允许对**行列子集视图**进行更新，但对其他类型视图的更新不同系统有不同限制

> 有些视图更新不能唯一地有意义地转换成对基本表的更新，自然就不可更新了。比如说一个包含平均值的视图，更新时不可能去更新基本表的几项的平均值，这没有意义。

### 视图的作用

1. 视图能够**简化**用户的操作
2. 视图使用户能以**多种角度**看待同一数据
3. 视图对重构数据库提供了一定程度的**逻辑独立性**
4. 视图能够对机密数据提供**安全保护**
5. 适当的利用视图可以更**清晰**的表达查询

# 四、数据库安全性





































# 考试重点

作业+实验+考试

**所有作业都要会做**

## 第一章

关系型数据库，人工，文件

数据库的基本概念：三层模型两级映射

概念模式

逻辑模型：关系的基本概念

数据库结构，*系统组成（不重要）*

## 第二章

关系、码、域、基本性质

三类完整性约束条件

⭐关系操作、关系代数

## 第三章（原则上都要考）

特征啥的理解就行，不考解答；性质要知道

数据定义、语法、含义，

数据查询：单表、连接、嵌套（不要求，尽量不要用，会扣分）

创建视图、更新、修改、删除

空值（了解）

## 第四章

安全级别啥的不重要

存取控制

自主、强制控制，区别、内容，不会太细

chapter25不重要，一带而过

## 第五章

触发器、断言（考试不要求）

完整性、相关条件的内容要知道，语法

## 第六章

关系模式与范式（BCNF之前要知道）

不考详细定义，考判定

## 第七章

需求分析不要

概念结构设计知道就行，不重点考察

逻辑结构设计转化啥的要会做，垂直和水平分解，**要求举例一定要举例**

## 第十章

事务的定义

故障恢复的过程中，日志，检查点

镜像不是重点

转储和日志需要

恢复策略没什么

## 第十一章

为什么会出问题，不一致性怎么解决，方式（封锁）怎么做的

写锁读锁

三个协议

死锁活锁

事务调度（串行、两段锁）

意向锁
